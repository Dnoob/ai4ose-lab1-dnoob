# Lab1：裸机程序 —— 在"空电脑"上打印 Hello, world!

## 你会学到什么

完成本实验后，你将理解：
- 程序平时靠什么在运行（执行环境）
- 没有操作系统时，怎么让程序跑起来
- RISC-V 的三个特权级（M/S/U）是什么
- SBI 是什么，为什么需要它

> 遇到不熟悉的术语？查看[术语表](../glossary.md)

## 前置要求

- 已完成环境搭建（见根目录的环境搭建指南）
- 能在终端执行 `cargo build` 和 `qemu-system-riscv64 --version`
- 不需要 Rust 经验，本文会解释用到的每个语法

---

## 第一节：为什么 Hello, world! 并不简单？

不管你用什么编程语言，打印一行 "Hello" 都只要一行代码。但你有没有想过，这行代码背后发生了什么？

```
你写的代码:  打印 "Hello"
     ↓
编程语言的标准库:  调用操作系统的 write 接口
     ↓
操作系统内核:  找到屏幕对应的设备驱动
     ↓
设备驱动:  把字符写到硬件寄存器
     ↓
硬件:  屏幕上出现 "Hello"
```

你的代码站在最顶层，下面有 4 层在替你干活。本实验要做的事情是：**拆掉中间所有层，直接站在硬件上，把字打印出来。**

---

## 第二节：认识 RISC-V 特权级

RISC-V CPU 有三个权限等级，从高到低：M-mode（Machine Mode）、S-mode（Supervisor Mode）、U-mode（User Mode）。

类比一家银行：M-mode 是金库管理员，掌控所有资源；S-mode 是柜员，处理客户请求；U-mode 是客户，办业务必须通过柜员。

它们之间通过 `ecall` 指令通信——就是"取号递申请"：
- 客户（U-mode）向柜员（S-mode）："帮我把这笔钱转出去"——这叫**系统调用**
- 柜员（S-mode）向金库管理员（M-mode）："需要开一下金库"——这叫 **SBI 调用**

### SBI 是什么？

SBI（Supervisor Binary Interface）就是金库管理员对外提供的"服务窗口"。它运行在 M-mode，为 S-mode 提供最基础的硬件操作服务：

| SBI 服务 | 作用 |
|----------|------|
| `console_putchar(c)` | 输出一个字符到屏幕 |
| `shutdown(fail)` | 关机 |

本实验中，我们使用 `tg-sbi` 这个 Rust crate（可以理解为别人写好的库，类似 Python 的 pip 包或 C++ 的第三方库）来调用 SBI 服务。

---

## 第三节：理解项目结构

```
lab1/
├── .cargo/
│   └── config.toml      # 告诉 cargo：编译目标是 RISC-V，用 QEMU 运行
├── build.rs              # 编译前自动运行，生成链接脚本
├── Cargo.toml            # 项目配置：名称、依赖哪些 crate
├── rust-toolchain.toml   # 指定 Rust 工具链版本
├── src/
│   └── main.rs           # 👈 你唯一需要修改的文件
├── README.md             # 本文档
└── exercises.md          # 课后习题
```

这些文件各司其职，配合完成一件事：**把你写的代码编译成 RISC-V 程序，放到 QEMU 虚拟机里运行。**

| 文件 | 做什么 | 类比 |
|------|--------|------|
| `config.toml` | 告诉 cargo 编译目标是 RISC-V，运行时用 QEMU | 告诉工厂"这个产品要出口到哪个国家，用什么快递发" |
| `build.rs` | 编译前自动生成链接脚本，决定代码放在内存的什么位置 | 告诉搬家公司"这些家具分别放到哪个房间" |
| `Cargo.toml` | 声明项目依赖了 `tg-sbi`（SBI 服务库） | 购物清单：这个项目需要用到哪些外部库 |
| `src/main.rs` | 你的代码，程序的核心逻辑 | 房子本身 |

### 启动流程

当你执行 `cargo run` 时，发生了这些事：

```
cargo 编译你的代码 → 生成 RISC-V 可执行文件
  ↓
cargo 自动启动 QEMU，把可执行文件加载到虚拟机
  ↓
QEMU 模拟电脑通电
  ↓
M-mode 固件（tg-sbi）先运行，初始化硬件
  ↓
固件把控制权交给 _start（已写好，设置栈指针）
  ↓
_start 跳转到 rust_main → 👈 你写的代码从这里开始！
  ↓
打印 "Hello, world!" → 关机 → QEMU 退出
```

你不需要记住每一步的细节，只需要知道：**固件先跑，帮你把硬件准备好，然后把控制权交给你的代码。** 具体的内存地址和底层细节，在第五节代码解读中会详细讲。

---

## 第四节：动手实验

### 步骤 0：确认环境

```bash
cd lab1
cargo build
```

编译成功（没有 error）说明环境没问题。现在试试运行：

```bash
cargo run
```

你会发现程序**卡住不动**，没有任何输出。这是正常的——因为 `src/main.rs` 里的函数现在都是空的 `loop {}`（死循环）。按 `Ctrl+C` 退出，然后我们来填代码。

### 步骤 1：实现 panic_handler

打开 `src/main.rs`，找到 `TODO 1`。

**目标**：让程序出错时能关机，而不是卡死。

**背景**：Rust 要求 `#![no_std]` 的程序必须定义一个 panic_handler——告诉编译器"程序出错了怎么办"。在裸机上没别的选择，出错了只能关机。

**要做的事**：调用 `shutdown(true)` 关机。`true` 表示异常退出。写完后删掉 `loop {}`。

填完后验证：

```bash
cargo build
```

能通过就进入下一步。

### 步骤 2：实现 rust_main

找到 `TODO 2`。

**目标**：在屏幕上打印 `Hello, world!` 然后正常关机。

**你能用的工具**：

- `console_putchar(c)` —— 输出一个字符到屏幕
- `shutdown(false)` —— 正常关机
- `b"Hello, world!\n"` —— 字节字符串，可以用 for 循环遍历

**思路**：一次只能输出一个字符，所以需要循环遍历字符串的每个字节，逐个输出。输出完后关机。

<details>
<summary>还是没思路？点这里看更具体的提示</summary>

```rust
for c in b"Hello, world!\n" {
    // c 是 &u8（字节的引用），需要用 *c 取出值
    // 然后传给 console_putchar
}
// 循环结束后调用 shutdown
```

</details>

填完后运行：

```bash
cargo run
```

**预期输出**：

```
Hello, world!
```

看到这行字，QEMU 自动退出——恭喜，你的第一个裸机程序跑起来了！

---

## 第五节：代码是怎么跑起来的？

你已经让 `Hello, world!` 出现在屏幕上了。现在我们从你写的代码出发，一层层往下看它是怎么运行起来的。

### 你写的 rust_main 里发生了什么

```rust
extern "C" fn rust_main() -> ! {
    for c in b"Hello, world!\n" {
        console_putchar(*c);
    }
    shutdown(false)
}
```

几个你可能有疑问的地方：

- **`b"Hello, world!\n"`**：前面的 `b` 表示这是字节字符串，每个字符用一个字节表示。`"Hello"` 是文本字符串，`b"Hello"` 是字节数组 `[72, 101, 108, 108, 111]`
- **`*c`**：for 循环遍历时，`c` 拿到的是每个字节的引用（`&u8`），而 `console_putchar` 需要的是值（`u8`），所以用 `*` 取出实际的值
- **`-> !`**：表示这个函数永远不会返回。因为最后调了 `shutdown`，机器关了，当然回不来
- **`extern "C"`**：使用 C 语言的调用约定，因为 `_start` 是用汇编跳过来的，需要双方约定好参数怎么传递

### 谁在 rust_main 之前运行？

你的代码不是凭空就能跑的。在 `rust_main` 之前，`_start` 函数做了一件关键的事——**设置栈指针**：

```
la sp, STACK + 4096    // 把 sp 指向栈顶
j  rust_main           // 跳转到你的代码
```

为什么必须先设栈？因为 Rust 函数执行时需要用栈来存放局部变量、函数调用信息等。没有栈，任何普通函数都跑不了。

`_start` 本身是个**裸函数**（`#[unsafe(naked)]`）——它不会自动使用栈，所以可以在栈还没设好的时候运行。等它把栈设好，再跳到普通函数 `rust_main`。

**栈为什么是 STACK + 4096 而不是 STACK？** 因为栈从高地址往低地址增长。STACK 是数组开头（低地址），STACK + 4096 是数组末尾（高地址）。sp 要指向栈顶，也就是高地址那一端。

### 代码怎么到了正确的内存位置？

QEMU 通电后，M-mode 固件（tg-sbi）先初始化硬件，然后跳转到地址 `0x80200000` 把控制权交给我们。所以我们的 `_start` 必须正好在这个位置。

这就是**链接脚本**的工作——`build.rs` 在编译前自动生成链接脚本，告诉编译器：

```
0x80000000  →  M-mode 固件的代码放这里
0x80200000  →  我们的代码放这里，_start 排在最前面
```

`0x80200000` 不是我们随便选的，而是 QEMU virt 平台上固件和内核之间的约定。

### stub 模块

`src/main.rs` 末尾有一个 `#[cfg(not(target_arch = "riscv64"))]` 的 stub 模块，它只在你的 x86 电脑上编译时生效，提供一些占位符号让编译检查能通过。跟内核逻辑无关，不用管。

---

## 第六节：总结

本实验中，你在一台没有操作系统的"空电脑"上打印了一行字。完整流程如下：

```
cargo run
  ↓
编译代码，生成 RISC-V 可执行文件
  ↓
QEMU 启动，模拟一台 RISC-V 电脑
  ↓
M-mode 固件（tg-sbi）初始化硬件
  ↓
跳转到 _start → 设置栈指针
  ↓
跳转到 rust_main（你写的代码）
  ↓
for 循环逐字符调用 console_putchar → SBI 把字符输出到屏幕
  ↓
调用 shutdown → SBI 关机 → QEMU 退出
```

整个过程没有操作系统参与，你的代码直接站在硬件的固件接口上运行。

但这台"电脑"现在有一个很大的局限：**它只能运行一个程序。** `rust_main` 跑完就关机了，没法接着运行第二个程序。如果想让它依次运行多个程序，而且某个程序出了 bug 不会把整台机器搞崩——该怎么办？这就是 Lab2 要解决的问题。

完成实验后，试试[习题](exercises.md)检验理解。如果实验中遇到困难，可以参考[参考答案](../solutions/lab1/src/main.rs)。
