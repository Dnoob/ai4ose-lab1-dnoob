# Day2 AI 对话记录（2026.02.12）

**平台**：Claude
**模型**：Opus4.6
**时间**：20:45 - 23:07

---

## 1. 任务规划与 ch1/ch2 复习

**用户 (20:45)**

hi，我们今天的任务是复习ch1 和 ch2 并 制定实验环境框架 和 编写实验指导文档

**Claude (20:45)**

好，我对你的进展很清楚了。你已经跑通了 ch1/ch2，逐行分析过源码，也理解了核心概念。今天的任务是从"看懂"转向"动手做"。

我建议今天分三步走：

1. **快速复习 ch1/ch2 核心知识点**（确认理解到位）
2. **设计实验环境的整体框架**（目录结构、每章实验的定位）
3. **开始编写 ch1 的实验指导文档 + 实验代码骨架**

先从复习开始。我用提问的方式帮你检验理解，你简单回答就行，不确定的我补充：

**ch1 快速检验：**

1. `#![no_std]` 和 `#![no_main]` 分别去掉了什么？为什么裸机环境必须加？
2. 程序入口地址为什么是 `0x80200000`？
3. SBI 在整个启动流程中扮演什么角色？

先回答这三个，然后我们接着过 ch2 的。

**用户 (20:47)**

1.去掉标准库和main入口。裸机环境没有这些
2.SBI固定的
3.固件

**Claude (20:47)**

对，都答到点上了。补充两个细节：

- `0x80200000` 是 QEMU virt 平台上 OpenSBI 的约定，换个平台可能不同。本质是 SBI 初始化完硬件后，跳转到这个地址把控制权交给内核。
- SBI 不只是"固件"，它还提供运行时服务（console_putchar、shutdown 等），内核随时可以通过 `ecall` 调用它。类比 C++ 的话，SBI 像一个常驻的 HAL（硬件抽象层）。

**ch2 快速检验：**

1. 批处理系统中，用户程序都被加载到同一个地址 `0x80400000`，为什么可以这样做？
2. Trap 发生时，CPU 硬件自动做了哪些事情？（不是软件做的，是硬件自动完成的）
3. `TrapContext` 保存了什么？为什么要保存？
4. 用户程序执行了非法指令（比如 `sret`），内核是怎么知道并处理的？

**用户 (20:49)**

1.不知道
2.不知道
3.好像保存了程序的入口地址。因为等下还要再返回进入
4.不知道

**Claude (20:49)**

好，这说明 ch2 的代码细节还需要再过一遍。逐个讲清楚：

### 1. 为什么都加载到 `0x80400000`？

因为是**批处理**——同一时间只有一个程序在跑。前一个跑完（exit）或出错（被杀），内核才把下一个程序加载到**同一个位置**，覆盖掉前一个的内存。

类比：一间教室同一时间只上一门课。上完数学课，下一节英语课进来用同一间教室，不需要两间。

### 2. Trap 时 CPU 硬件自动做的事

这是重点，很多人分不清哪些是硬件做的、哪些是软件做的。当 `ecall` 或异常触发时，**CPU 硬件自动**完成这四件事：

| 硬件自动做的 | 说明 |
|---|---|
| `scause` ← 原因 | 记录为什么陷入（ecall？非法指令？缺页？） |
| `sepc` ← 当前 PC | 记录陷入时用户程序执行到哪条指令 |
| `stval` ← 附加信息 | 比如访问了哪个非法地址 |
| `sstatus` 的 SPP 位 ← 当前特权级 | 记录陷入前是 U-mode 还是 S-mode |
| PC ← `stvec` | **跳转到内核预设的 trap 处理入口** |

之后的事（保存寄存器、分析原因、处理）全是**软件**（你写的内核代码）负责。

C++ 类比：硬件做的事像 CPU 的中断向量表跳转，软件做的事像你写的 signal handler。

### 3. TrapContext 保存了什么？

不只是入口地址，是**所有 32 个通用寄存器 + sstatus + sepc**。

```rust
pub struct TrapContext {
    pub x: [usize; 32],   // x0-x31，所有通用寄存器
    pub sstatus: usize,    // 陷入前的状态（特权级等）
    pub sepc: usize,       // 陷入时用户程序的 PC（执行到哪了）
}
```

**为什么要全部保存？** 因为内核处理 trap 时要用这些寄存器做自己的事，会覆盖掉用户程序的值。处理完之后要恢复所有寄存器，让用户程序感觉"什么都没发生过"继续跑。

C++ 类比：就像 `setjmp/longjmp`，保存和恢复执行现场。或者像线程切换时保存 CPU context。

### 4. 非法指令怎么被发现和处理的？

完整链条：

```
用户程序执行 sret（这是 S-mode 指令，U-mode 不能用）
  ↓
CPU 硬件检测到特权级违规
  ↓ 硬件自动
scause = IllegalInstruction, sepc = 出错指令地址
PC 跳转到 stvec（内核的 trap 入口）
  ↓ 软件接管
内核的 trap_handler 读取 scause
  ↓
发现是 IllegalInstruction，不是 ecall
  ↓
内核判定：这个用户程序违规了，杀掉它
  ↓
加载下一个用户程序继续运行
```

所以内核"知道"是因为 CPU 硬件把原因写进了 `scause`，内核只需要读这个寄存器就行。

---

## 2. 实验环境框架设计

**用户 (20:55)**

没疑问了。针对实验环境框架，有没有什么比较好的设计方案。我目前对于操作系统是零基础，我想设计一套针对零基础的教学环境。这是此次项目的最终目的。但是针对零基础，要怎么设计教学，用户是看不懂rust，也不懂任何操作系统的知识。就能依靠我们设计的课程，学会

**Claude (20:55)**

这是个好问题，也是整个项目最核心的设计决策。

### 核心矛盾

零基础学生同时面对三个陌生东西：Rust、RISC-V、OS 概念。如果三个一起上，必然崩溃。

解决思路：**拆开来，按需引入，每次只学一样新东西。**

### 设计理念：填空式渐进教学

不要让学生从零写一个内核。应该给学生一个**几乎完整但挖了几个关键洞的内核**，学生的任务是理解上下文，然后把洞填上。每一章挖的洞越来越大，最后学生的能力逐步成长到能写核心模块。

类比：学开车不是让你造一辆车，而是先让你坐副驾看，然后让你在空旷场地开，然后上路。

### 整体框架设计

```
ai4ose-lab1-dnoob/
├── docs/
│   ├── overview.md              # 课程总览、学习路线图
│   ├── setup-guide.md           # 环境搭建（保姆级）
│   ├── rust-survival-guide.md   # OS开发需要的最小Rust子集
├── labs/
│   ├── lab1/ - lab5/            # 实验代码（含骨架 + 填空点）
├── solutions/                   # 参考答案（完整实现）
├── tests/                       # 测试用例
├── ai-logs/                     # AI交互记录
└── weekly/                      # 周进展纪要
```

### 关键设计原则

**原则 1：Rust 按需教学，不单独开课**

**原则 2：每个步骤都能 cargo run 看到变化**

**原则 3：代码骨架用 TODO 标记填空点**

**原则 4：概念讲解用"三层法"**（一句话 + 类比 + 代码）

### 五个 Lab 的定位

| Lab | 主题 | 学生做什么 | 新引入的概念 |
|---|---|---|---|
| 1 | 裸机输出 | 补全 `rust_main`，实现字符输出和关机 | 裸机环境、SBI、链接脚本 |
| 2 | 批处理 | 实现 TrapContext 保存恢复 + 两个系统调用 | 特权级、Trap、系统调用 |
| 3 | 分时系统 | 实现时钟中断 + 任务切换 | 中断、调度、时间片 |
| 4 | 虚拟内存 | 实现页表映射 + 内核/用户地址空间 | 页表、地址空间、MMU |
| 5 | 进程 | 实现 fork/exec/waitpid | 进程、进程树、资源管理 |

---

## 3. 目录结构调整

**用户 (21:02)**

文件目录排行需要改一下，不要所有都放在docs下

**Claude (21:02)**

（调整为每个 lab 独立目录，docs/ 只放全局文档）

---

## 4. 命名讨论：lab vs ch

**用户 (21:03)**

叫lab1 好，还是ch1

**Claude (21:03)**

建议用 **lab**。理由：

- 参考代码叫 ch（chapter），你的叫 lab 能明确区分——"ch 是我学的，lab 是我做的"
- 你的定位是教学**实验**环境，lab 更贴切，强调动手
- 学生看到 lab 就知道要写代码，看到 ch 会以为是阅读材料

---

## 5. Lab1 README 逐节讨论

### 第一节：Hello world 的类比

**用户 (21:17)**

（指出 Python 类比对不懂 Python 的人不适用）

**Claude**

（先后给出微信类比、水龙头类比，用户都不满意）

**用户 (21:21)**

就用python那个，但是需要换个更通用的

**Claude (21:21)**

最终方案——不提具体语言：

> 不管你用什么编程语言，打印一行 "Hello" 都只要一行代码。但你有没有想过，这行代码背后发生了什么？

### 第二节：特权级类比

**用户 (21:26)**

（指出办公楼类比不合理：普通员工请求老板写文件）

**Claude (21:26)**

改为银行类比：金库管理员 / 柜员 / 客户

**用户 (21:30)**

字太多了。还有类比应该一直待在银行场景里。

**Claude (21:30)**

最终方案：

- 客户（U-mode）向柜员（S-mode）："帮我把这笔钱转出去"——这叫**系统调用**
- 柜员（S-mode）向金库管理员（M-mode）："需要开一下金库"——这叫 **SBI 调用**

### 术语表讨论

**用户 (21:33 - 21:42)**

连续提出 Rust crate、cargo、QEMU 是什么的问题，最终决定：

- 单独建 `glossary.md`（术语表），放根目录
- 每个 lab 的 README 开头加链接指过去

### 第三节：项目结构

**用户 (21:48)**

假设你是一个顶尖操作系统专家+顶尖的教学专家。你认为第三节这样设置需要修改吗

**Claude (21:48)**

两个问题：

1. 项目结构和启动流程之间缺少连接
2. 启动流程里的十六进制地址对零基础学生太突兀

改后版本：加表格关联文件与作用、启动流程从 `cargo run` 开始讲、去掉十六进制地址。

### 第四节：动手实验

**用户 (21:53)**

你觉得呢，请你以一个顶尖操作系统专家+顶尖的教学专家 的角度来思考

**Claude (21:53)**

5 个问题：

1. 步骤 0 描述有误（不会 panic，是死循环）
2. README 里贴大段代码与 main.rs 重复
3. TODO 2 的提示把答案全给了
4. C++ 类比不该出现在零基础文档
5. 步骤 3（可选探索）没有加深理解

**用户 (21:59)**

步骤 3 的意义是什么，有必要吗

**Claude**

说实话意义不大。建议砍掉。

### 第五节：代码解读

**用户 (22:05)**

你觉得呢

**Claude (22:05)**

3 个问题：

1. `#![no_std]` 和 `#![no_main]` 重复讲了
2. 没解释学生自己写过的代码（`*c`、`extern "C"`、`-> !`）
3. 应该围绕学生的问题组织，而不是从上到下念代码

改后结构：从 rust_main 出发 → `_start` → 链接脚本 → stub 一笔带过

### 第六节：总结

**用户 (22:15)**

你觉得呢

**Claude (22:15)**

2 个问题：

1. 总结不该是知识点清单
2. 缺少对 Lab2 的问题铺垫

**用户 (22:16)**

有没有流程图之类的

**Claude**

最终版本：流程图 + "只能运行一个程序"的局限引出 Lab2

---

## 6. README 完整检查

**用户 (22:18)**

这是全部内容，帮我检查下

**Claude (22:18)**

发现 6 个问题：

1. "一栋银行"→"一家银行"
2. 折叠提示缺少代码块标记和空行
3. 第五节标题用了加粗而非 `###`
4. `*c` 的反斜杠转义问题
5. 缺少术语表链接
6. 前置要求的链接路径错误

---

## 7. main.rs 骨架代码讨论

**用户 (22:29)**

请你以一个顶尖操作系统专家+顶尖的教学专家 的角度来思考

**Claude (22:29)**

重要结构问题：学生打开文件首先看到吓人的 `_start` 汇编代码，要往下翻才能找到 TODO。建议把 TODO 提到前面。

**用户 (22:30)**

//! 和 // 的区别是什么

**Claude**

- `//` 是普通注释
- `//!` 是模块文档注释，会被 `cargo doc` 提取

**用户 (22:31)**

还是使用//! ，规范一点

**用户 (22:33)**

感觉没什么差别（调整顺序后）

**Claude**

确实，文件本来就不长。这个版本就可以了。

---

## 8. exercises.md 讨论

**用户 (22:39)**

代码题会不会太多了

**Claude**

确实，题目 1 和题目 2 本质上都在练 for 循环，重复了。

**用户 (22:42)**

不要代码题了

最终方案：4 道判断 + 2 道选择，单独文件维护。

---

## 9. 文件生成与测试

**用户 (22:43)**

生成这些

（Claude 生成全部文件，打包为 tar.gz）

**服务器测试 (22:52)**

```
root@iv-yefg24rbpccva4h5cfjh:~/ai4ose-lab1-dnoob/solutions/lab1# cargo run
   Compiling lab1-bare-metal-solution v0.1.0
   Compiling tg-sbi v0.1.0-preview.1
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.51s
     Running `qemu-system-riscv64 -machine virt -nographic -bios none -kernel ...`
Hello, world!
```

✅ 参考答案验证通过。

---

## 10. Git 提交与修复

提交时 `target/` 目录被误提交（80 个编译产物文件）。修复：

```bash
echo "target/" >> .gitignore
git rm -r --cached solutions/lab1/target/
git commit -m "fix: remove build artifacts and add .gitignore"
git push
```

---

## 11. 补充：solution 链接

在 lab1 README 末尾添加：

```markdown
完成实验后，试试[习题](exercises.md)检验理解。如果实验中遇到困难，可以参考[参考答案](../solutions/lab1/src/main.rs)。
```

---

## 12. 进度记录与对话导出

讨论了 Day2 进度模板格式和 AI 对话导出方式（建议浏览器打印为 PDF）。
